{
    "selfpaced": false, 
    "topic_name": [
        "Theoretical Computer Science"
    ], 
    "description": "\n\n                    \n                    \n                    A good algorithm usually comes together with a set of good data structures that allow the algorithm to manipulate the data efficiently. In this course, we consider the common data structures that are used in various computational problems. You will learn how these data structures are implemented in different programming languages and will practice implementing them in our programming assignments. This will help you to understand what is going on inside a particular built-in implementation of a data structure and what to expect from it. You will also learn typical use cases for these data structures.\n\nA few examples of questions that we are going to cover in this class are the following:\n1. What is a good strategy of resizing a dynamic array?\n2. How priority queues are implemented in C++, Java, and Python?\n3. How to implement a hash table so that the amortized running time of all operations is O(1) on average?\n4. What are good strategies to keep a binary tree balanced? \n\nYou will also learn how services like Dropbox manage to upload some large files instantly and to save a lot of storage space!\n\n                                            Syllabus\n                        Basic Data StructuresIn this module, you will learn about the basic data structures used throughout the rest of this course.  We start this module by looking in detail at the fundamental building blocks: arrays and linked lists. From there, we build up two important data structures: stacks and queues. Next, we look at trees: examples of how they’re used in Computer Science, how they’re implemented, and the various ways they can be traversed. Finally, we discuss Dynamic Arrays: a way of using arrays when it is unknown ahead-of-time how many elements will be needed. Here, we also discuss amortized analysis: a method of determining the amortized cost of an operation over a sequence of operations. Once you’ve completed this module, you will be able to implement any of these data structures, as well as have a solid understanding of the costs of the operations, as well as the tradeoffs involved in using each data structure.Priority Queues and Disjoint SetsWe start this module by considering priority queues which are used to efficiently schedule jobs, either in the context of a computer operating system or in real life, to sort huge files, which is the most important building block for any Big Data processing algorithm, and to efficiently compute shortest paths in graphs, which is a topic we will cover in our next course. For this reason, priority queues have built-in implementations in many programming languages, including C++, Java, and Python. \n\nWe will see that these implementations are based on a beautiful idea of storing a complete binary tree in an array that allows to implement all priority queue methods in just few lines of code. We will then switch to disjoint sets data structure that is used, for example, in dynamic graph connectivity and image processing. We will see again how simple and natural ideas lead to an implementation that is both easy to code and very efficient.\n\nBy completing this module, you will be able to implement both these data structures efficiently from scratch.Hash TablesIn this module you will learn about very powerful and widely used technique called hashing. Its applications include implementation of programming languages, file systems, pattern search, distributed key-value storage and many more. You will learn how to implement data structures to store and modify sets of objects and mappings from one type of objects to another one. You will see that naive implementations either consume huge amount of memory or are slow, and then you will learn to implement hash tables that use linear memory and work in O(1) on average! In the end, you will learn how hash functions are used in modern distibuted systems and how they are used to optimize storage of services like Dropbox, Google Drive and Yandex Disk!Binary Search TreesIn this module we study binary search trees, which are a data structure for doing searches on dynamically changing ordered sets. You will learn about many of the difficulties in accomplishing this task and the ways in which we can overcome them. In order to do this you will need to learn the basic structure of binary search trees, how to insert and delete without destroying this structure, and how to ensure that the tree remains balanced.Binary Search Trees 2In this module we continue studying binary search trees. We study a few non-trivial applications. We then study the new kind of balanced search trees - Splay Trees. They adapt to the queries dynamically and are optimal in many ways.\n                                    ", 
    "end_date": "2016-07-25T00:00:00Z", 
    "title": "Data Structures", 
    "price": 0, 
    "instructors": "Pavel  Pevzner, Alexander S. Kulikov and Michael Levin", 
    "institution_name": [
        "University of California, San Diego ", 
        "Higher School of Economics"
    ], 
    "commitment": "", 
    "subject_name": [
        "Computer Science"
    ], 
    "course_url": "https://www.coursera.org/learn/data-structures", 
    "duration": "5 weeks", 
    "language_name": [
        "English"
    ], 
    "provider_name": [
        "Coursera"
    ], 
    "start_date": "2016-06-20T00:00:00Z"
}