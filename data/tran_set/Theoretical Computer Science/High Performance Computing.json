{"selfpaced": true, "topic_name": ["Theoretical Computer Science"], "description": "\n\n                    \n                    \n                    The goal of this course is to give you solid foundations for developing, analyzing, and implementing parallel and locality-efficient algorithms. This course focuses on theoretical underpinnings. To give a practical feeling for how algorithms map to and behave on real systems, we will supplement algorithmic theory with hands-on exercises on modern HPC systems, such as Cilk Plus or OpenMP on shared memory nodes, CUDA for graphics co-processors (GPUs), and MPI and PGAS models for distributed memory systems.\n\nThis course is a graduate-level introduction to scalable parallel algorithms. \u201cScale\u201d really refers to two things: efficient as the problem size grows, and efficient as the system size (measured in numbers of cores or compute nodes) grows. To really scale your algorithm in both of these senses, you need to be smart about reducing asymptotic complexity the way you\u2019ve done for sequential algorithms since CS 101; but you also need to think about reducing communication and data movement. This course is about the basic algorithmic techniques you\u2019ll need to do so.\n\nThe techniques you\u2019ll encounter covers the main algorithm design and analysis ideas for three major classes of machines: for multicore and many core shared memory machines, via the work-span model; for distributed memory machines like clusters and supercomputers, via network models; and for sequential or parallel machines with deep memory hierarchies (e.g., caches). You will see these techniques applied to fundamental problems, like sorting, search on trees and graphs, and linear algebra, among others. The practical aspect of this course is implementing the algorithms and techniques you\u2019ll learn to run on real parallel and distributed systems, so you can check whether what appears to work well in theory also translates into practice. (Programming models you\u2019ll use include Cilk Plus, OpenMP, and MPI, and possibly others.)Why Take This Course?\n\n                                            Syllabus\n                        The course topics are centered on three different ideas or extensions to the usual serial RAM model you encounter in CS 101. Recall that a serial RAM assumes a sequential or serial processor connected to a main memory.\n\n* Unit 1: The work-span or dynamic multithreading model\n\nIn this model, the idea is that there are multiple processors connected to the main memory. Since they can all \u201csee\u201d the same memory, the processors can coordinate and communicate via reads and writes to that \u201cshared\u201d memory.\n\nSub-topics include:\n\n** Intro to the basic algorithmic model\n** Intro to OpenMP, a practical programming model\n** Comparison-based sorting algorithms\n** Scans and linked list algorithms\n** Tree algorithms\n** Graph algorithms, e.g., breadth-first search\n\n* Unit 2: Distributed memory or network models\n\nIn this model, the idea is that there is not one serial RAM, but many serial RAMs connected by a network. In this model, each serial RAM\u2019s memory is private to the other RAMs; consequently, the processors must coordinate and communicate by sending and receiving messages.\n\nSub-topics include:\n\n** The basic algorithmic model\n** Intro to the Message Passing Interface, a practical programming model\n** Reasoning about the effects of network topology\n** Dense linear algebra\n** Sorting\n** Sparse graph algorithms\n** Graph partitioning\n\n* Unit 3: Two-level memory or I/O models\n\nIn this model, we return to a serial RAM, but instead of having only a processor connected to a main memory, there is a smaller but faster scratchpad memory in between the two. The algorithmic question here is how to use the scratchpad effectively, in order to minimize costly data transfers from main memory.\n\nSub-topics include:\n\n** Basic models\n** Efficiency metrics, including \u201cemerging\u201d metrics like energy and power\n** I/O-aware algorithms\n** Cache-oblivious algorithms\n                                    ", "end_date": "2016-03-30T00:00:00Z", "title": "High Performance Computing", "price": 0, "instructors": "Rich Vuduc", "institution_name": ["Georgia Institute of Technology", "Georgia Tech Online Master of Science in Computer Science"], "commitment": "6 hours", "subject_name": ["Computer Science"], "course_url": "https://www.udacity.com/course/high-performance-computing--ud281?utm_medium=referral&utm_campaign=api", "duration": "24 weeks", "language_name": ["English"], "provider_name": ["Udacity"], "start_date": "2015-10-14T00:00:00Z"}