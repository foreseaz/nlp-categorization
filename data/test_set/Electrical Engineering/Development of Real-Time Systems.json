{"selfpaced": false, "topic_name": ["Electrical Engineering"], "description": "\n\n                    \n                    \n                    This course is intended for the Master's student and computer engineer who likes practical programming and problem solving!\nAfter completing this course, you will have the knowledge to plan and set-up a real-time system both on paper and in practice.\n\nThe course centers around the problem of achieving timing correctness in embedded systems, which means to guarantee that the system reacts within the real-time requirements.\nExamples of such systems include airbags, emergency breaks, avionics, and also multi-media systems like video playback and QoS in web servers.\n\nThe course teaches how to plan real-time systems in theory using established mathematical proofs and how to implement them in practice by using the most common scheduling methods.\nWe also learn and how to program the system in the C language using the FreeRTOS real-time kernel.\nFinally we have a look at the future of real-time systems namely multi-core real-time systems!\n\nThis course focus on the learn-by-doing approach with many examples and real-world programming assignments.\nWe have 5 modules, each with a gentle graded quiz in the end and one peer reviewed programming assignment.\nIn case you have no experience with C programming, please check you a practical course like:\nhttps://www.coursera.org/learn/arduino-platform\n\nThe course is actually quite fun!\n-Simon Holmbacka / \u00c5bo Akademi University\n\nCheck out our whole curriculum: https://research.it.abo.fi/\n\n                                            Syllabus\n                        Introduction to Real-Time SystemsHere is where it all starts! We will make a brave attempt to start your future career in real-time systems! This week starts by learning the basic building stones in real-time systems and the system parameters required to successfully construct a real-time system. We introduce you to the corner stone of real-time systems, namely the scheduler \u2013 and its task in real-time schedules. You learn also what kind of real-time guarantees are needed in which systems. Concretely, you will learn (1) What is needed to create a real-time system (2) Where real-time requirements are needed. (3) The task and job structure and the parameters needed to schedule a task. (4) Difference between pre-emptive and non-pre-emptive tasks.Static SchedulingIn this week we start to actually do some scheduling. We firstly have a look at the simplest type of scheduler \u2013 the clock driven scheduler. After this we deepen our learning with the fixed priority scheduler and the monotonic schedulers. We learn how the priorities are determined using these schedulers and we learn when/when not to use these schedulers. Secondly we learn how to determine if a system is overloaded in order to validate schedules without complete system simulation.Concretely, after attending this week you will be able to:   (1) Schedule a set of tasks with the clock driven scheduler, with the fixed priority scheduler, with the monotonic schedulers.   (2) Determine if a system is overloaded using the total-utilization method and the Urm method.   (3) Program FreeRTOS to schedule a set of tasks using the fixed priority scheduler Dynamic SchedulingIn the previous week we learned the limitations of the total-utilization method and the Urm method. We start this week off by extending these tests to tasks with short response times. The new method is also, as usual, used in practice! We then focus on improving the optimality of real-time schedules. This is done by learning the principles behind dynamic scheduling methods. Two new schedulers using the dynamic scheduling principle is learned and used in practice with a few examples; the LST scheduler and the EDF scheduler.Concretely, you will learn: (1) How to determine feasibility of a set of tasks using the time demand analysis method.  (2) How to schedule a set of tasks using LST and EDF.  (3) To determine when a dynamic scheduler is appropriate and when it is not appropriate.Non-Periodic JobsAll things are easy and nice when not caring about non-periodic jobs. When including non-periodic jobs, the schedulers must take these into account to make a feasible schedule, which we learn this week. The problem is that a non-periodic job can arrive at any time, even if a periodic job is already scheduled. We learn both how to optimize a schedule for non-periodic jobs and how to validate a schedule when non-periodic jobs arrive to the schedule.\nConcretely, we will learn: (1) How to use the slack stealing method to optimize a schedule with non-periodic jobs (2) How to use the LRT scheduler to optimize a schedule with non-periodic jobs (3) How to use the deferrable server to optimize a schedule with non-periodic jobs (4) Formally verify a schedule with non-periodic jobs\nReal-Time Operating SystemsThis week is what we all have been waiting for! We will deepen our learning of FreeRTOS, its kernel and the functionalities. We demonstrate the importance of predictable computer architectures for example when determining the context switch and factors influencing this overhead. As we head towards the future, we finish this course by introducing you to multi-core real-time systems and scheduling methods for multi-core real-time systems. Concretely, you will learn:  (1) The internal mechanisms of FreeRTOS, for example mutexes/semaphores and message queues. (2) Multi-core computer architectures for real-time systems. (3) Multi-core scheduling methods.\n                                    ", "end_date": "2016-07-18T00:00:00Z", "title": "Development of Real-Time Systems", "price": 0, "instructors": "Simon Holmbacka", "institution_name": ["EIT Digital "], "commitment": "", "subject_name": ["Engineering"], "course_url": "https://www.coursera.org/learn/real-time-systems", "duration": "5 weeks", "language_name": ["English"], "provider_name": ["Coursera"], "start_date": "2016-06-13T00:00:00Z"}